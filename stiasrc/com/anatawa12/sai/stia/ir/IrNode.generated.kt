/**
 * Generated by IrNode.kts
 * Do not modify manually
 */

package com.anatawa12.sai.stia.ir

import com.anatawa12.autoVisitor.HasAccept
import com.anatawa12.autoVisitor.HasVisitor

@HasAccept("visitBinaryOperator", IrExpression::class)
class IrBinaryOperator(
    val type: IrBinaryOperatorType,
    left: IrExpression,
    right: IrExpression,
) : IrExpression() {
    var left: IrExpression by nodeDelegateOfIrExpression()
    var right: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.left = left
        this.right = right
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(left)
        func(right)
    }

    override fun toString() = "IrBinaryOperator(" +
        "type=$type" + ", " +
        "left=$left" + ", " +
        "right=$right" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitBinaryOperator(this, arg)
}

@HasAccept("visitUnaryOperator", IrExpression::class)
class IrUnaryOperator(
    val type: IrUnaryOperatorType,
    expr: IrExpression,
) : IrExpression() {
    var expr: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.expr = expr
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(expr)
    }

    override fun toString() = "IrUnaryOperator(" +
        "type=$type" + ", " +
        "expr=$expr" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitUnaryOperator(this, arg)
}

@HasAccept("visitGetProperty", IrExpression::class)
class IrGetProperty(
    owner: IrExpression,
    name: IrExpression,
    val isProp: Boolean,
) : IrExpression() {
    var owner: IrExpression by nodeDelegateOfIrExpression()
    var name: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.owner = owner
        this.name = name
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(owner)
        func(name)
    }

    override fun toString() = "IrGetProperty(" +
        "owner=$owner" + ", " +
        "name=$name" + ", " +
        "isProp=$isProp" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitGetProperty(this, arg)
}

@HasAccept("visitSetProperty", IrExpression::class)
class IrSetProperty(
    owner: IrExpression,
    name: IrExpression,
    value: IrExpression,
    val isProp: Boolean,
) : IrExpression() {
    var owner: IrExpression by nodeDelegateOfIrExpression()
    var name: IrExpression by nodeDelegateOfIrExpression()
    var value: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.owner = owner
        this.name = name
        this.value = value
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(owner)
        func(name)
        func(value)
    }

    override fun toString() = "IrSetProperty(" +
        "owner=$owner" + ", " +
        "name=$name" + ", " +
        "value=$value" + ", " +
        "isProp=$isProp" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitSetProperty(this, arg)
}

@HasAccept("visitPropertyOperatorAssign", IrExpression::class)
class IrPropertyOperatorAssign(
    owner: IrExpression,
    name: IrExpression,
    val isProp: Boolean,
    val operator: IrBinaryOperatorType,
    operand: IrExpression,
) : IrExpression() {
    var owner: IrExpression by nodeDelegateOfIrExpression()
    var name: IrExpression by nodeDelegateOfIrExpression()
    var operand: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.owner = owner
        this.name = name
        this.operand = operand
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(owner)
        func(name)
        func(operand)
    }

    override fun toString() = "IrPropertyOperatorAssign(" +
        "owner=$owner" + ", " +
        "name=$name" + ", " +
        "isProp=$isProp" + ", " +
        "operator=$operator" + ", " +
        "operand=$operand" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitPropertyOperatorAssign(this, arg)
}

@HasAccept("visitNewOrCall", IrExpression::class)
class IrNewOrCall(
    function: IrExpression,
    args: List<IrExpression>,
    val isNewInstance: Boolean,
) : IrExpression() {
    var function: IrExpression by nodeDelegateOfIrExpression()
    private val argsDelegate = nodeListDelegateOfIrExpression()
    val args: MutableList<IrExpression> by argsDelegate
    fun setArgs(args: List<IrExpression>) = argsDelegate.set(args)

    init {
        this.function = function
        setArgs(args)
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(function)
        args.forEach{ it.let(func) }
    }

    override fun toString() = "IrNewOrCall(" +
        "function=$function" + ", " +
        "args=$args" + ", " +
        "isNewInstance=$isNewInstance" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitNewOrCall(this, arg)
}

@HasAccept("visitCommaExpr", IrExpression::class)
class IrCommaExpr(
    exprs: List<IrExpression>,
) : IrExpression() {
    private val exprsDelegate = nodeListDelegateOfIrExpression()
    val exprs: MutableList<IrExpression> by exprsDelegate
    fun setExprs(exprs: List<IrExpression>) = exprsDelegate.set(exprs)

    init {
        setExprs(exprs)
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        exprs.forEach{ it.let(func) }
    }

    override fun toString() = "IrCommaExpr(" +
        "exprs=$exprs" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitCommaExpr(this, arg)
}

@HasAccept("visitConditional", IrExpression::class)
class IrConditional(
    condition: IrExpression,
    ifTrue: IrExpression,
    ifFalse: IrExpression,
) : IrExpression() {
    var condition: IrExpression by nodeDelegateOfIrExpression()
    var ifTrue: IrExpression by nodeDelegateOfIrExpression()
    var ifFalse: IrExpression by nodeDelegateOfIrExpression()

    init {
        this.condition = condition
        this.ifTrue = ifTrue
        this.ifFalse = ifFalse
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
        func(condition)
        func(ifTrue)
        func(ifFalse)
    }

    override fun toString() = "IrConditional(" +
        "condition=$condition" + ", " +
        "ifTrue=$ifTrue" + ", " +
        "ifFalse=$ifFalse" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitConditional(this, arg)
}

// convert java exception to js object
@HasAccept("visitConvertException", IrExpression::class)
class IrConvertException(
    val internalVar: IrInternalVariableId,
) : IrExpression() {

    init {
    }

    @Suppress("OVERRIDE_BY_INLINE")
    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {
    }

    override fun toString() = "IrConvertException(" +
        "internalVar=$internalVar" +
    ")"

    override fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R = visitor.visitConvertException(this, arg)
}

@HasVisitor(
    visitorType = IrExpressionVisitor::class,
    hasCustomDataParam = true,
    acceptName = "accept",
    subclasses = [
        IrBinaryOperator::class,
        IrUnaryOperator::class,
        IrGetProperty::class,
        IrSetProperty::class,
        IrPropertyOperatorAssign::class,
        IrNewOrCall::class,
        IrCommaExpr::class,
        IrConditional::class,
        IrConvertException::class,
        IrNumberLiteral::class,
        IrStringLiteral::class,
        IrNullLiteral::class,
        IrBooleanLiteral::class,
        IrRegexpLiteral::class,
        IrIncDec::class,
        IrNameIncDec::class,
        IrPropertyIncDec::class,
        IrSetName::class,
        IrGetName::class,
    ]
)
@HasAccept("visitExpression", IrExpression::class)
sealed class IrExpression : IrNode() {
    abstract fun runWithChildExpressions(func: (IrExpression) -> Unit)
    abstract fun <R, T> accept(visitor: IrExpressionVisitor<R, T>, arg: T): R
}

