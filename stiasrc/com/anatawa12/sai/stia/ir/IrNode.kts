/**
 * regenerate with command shown below:
 *
 * kotlinc -script IrNode.kts
 */

@file:JvmName("IrNodeGen")
@file:Suppress("PropertyName")

import java.io.File

val mainCode = StringBuilder()

fun addCode(stat: Any? = null) {
    if (stat == null) mainCode.appendLine()
    else stat.toString().removeSuffix("\n").takeUnless { it == "" }?.let(mainCode::appendLine)
}

val IrExpression = "IrExpression"
val IrStatement = "IrStatement"
val types = mutableMapOf<String, MutableList<String>>()

class ClassGen(val name: String, val parent: String) {
    init {
        types.getOrPut(parent) { mutableListOf() }
            .add(name)
    }

    private val params = StringBuilder()
    private val init = StringBuilder()
    private val toString = StringBuilder()
    private val body = StringBuilder()

    fun const(name: String, type: String) = addConstant(name, type)
    fun list(name: String, type: String) = addList(name, type)
    @Suppress("PropertyName")
    operator fun String.invoke(type: String) = add(this, type)
    @Suppress("PropertyName")
    operator fun String.unaryPlus() = add(this, IrExpression)

    private fun String.asFunName() = this.filter { it in 'a'..'z' || it in 'A'..'Z' }
        .let { if (endsWith('?')) "${it}Nullable" else it }

    fun addConstant(name: String, type: String) {
        params.appendLine("    val $name: $type,")
        toString.appendLine("        \"$name=\$$name, \" +")
    }

    fun add(name: String, type: String) {
        params.appendLine("    $name: $type,")
        init.appendLine("        this.$name = $name")
        toString.appendLine("        \"$name=\$$name, \" +")
        body.appendLine("    var $name: $type by nodeDelegateOf${type.asFunName()}()")
    }

    fun addList(name: String, type: String) {
        val setName = "set${name.let { it[0].toUpperCase() + it.substring(1) }}"
        params.appendLine("    $name: List<$type>,")
        init.appendLine("        $setName($name)")
        toString.appendLine("        \"$name=\$$name, \" +")
        body.appendLine("    private val ${name}Delegate = nodeListDelegateOf${type.asFunName()}()")
        body.appendLine("    val $name: MutableList<$type> by ${name}Delegate")
        body.appendLine("    fun $setName($name: List<$type>) = ${name}Delegate.set($name)")
    }

    fun print() {
        val visitName = "visit${name.removePrefix("Ir")}"
        addCode("@HasAccept(\"$visitName\", $parent::class)")
        addCode("class $name(")
        addCode(params)
        addCode(") : $parent() {")
        addCode(body)
        addCode()
        addCode("    init {")
        addCode(init)
        addCode("    }")
        addCode()
        addCode("    override fun toString() = \"$name(\" +")
        addCode(toString)
        addCode("    \")\"")
        addCode()
        addCode("    override fun <R, T> accept(visitor: ${parent}Visitor<R, T>, arg: T): R = visitor.$visitName(this, arg)")
        addCode("}")
        addCode()
    }
}

inline operator fun String.invoke(parent: String, block: ClassGen.() -> Unit) = ClassGen(this, parent).apply(block).print()

// header

val header = """
    /**
     * Generated by IrNode.kts
     * Do not modify manually
     */
    
    package com.anatawa12.sai.stia.ir
""".trimIndent()

addCode(header)
addCode()
addCode("import com.anatawa12.autoVisitor.HasAccept")
addCode("import com.anatawa12.autoVisitor.HasVisitor")
addCode()

// expressions

"IrBinaryOperator"(IrExpression) {
    const("type", "IrBinaryOperatorType")
    +"left"
    +"right"
}

"IrUnaryOperator"(IrExpression) {
    const("type", "IrUnaryOperatorType")
    +"expr"
}

"IrGetProperty"(IrExpression) {
    +"owner"
    +"name"
    const("isProp", "Boolean")
}

"IrSetProperty"(IrExpression) {
    +"owner"
    +"name"
    +"value"
    const("isProp", "Boolean")
}

"IrNewOrCall"(IrExpression) {
    +"function"
    list("args", IrExpression)
    const("isNewInstance", "Boolean")
}

"IrCommaExpr"(IrExpression) {
    list("exprs", IrExpression)
}

"IrConditional"(IrExpression) {
    +"condition"
    +"ifTrue"
    +"ifFalse"
}

"IrSetName"(IrExpression) {
    const("name", "String")
    +"value"
}

"IrGetName"(IrExpression) {
    const("name", "String")
}

addCode("// convert java exception to js object")
"IrConvertException"(IrExpression) {
    const("internalVar", "IrInternalVariableId")
}

// statements
"IrJumpTarget"(IrStatement) {
}

"IrReturn"(IrStatement) {
    add("value", "$IrExpression?")
}

"IrGoto"(IrStatement) {
    const("target", "IrJumpTarget")
}

"IrJsr"(IrStatement) {
    const("target", "IrJumpTarget")
}

"IrIfFalse"(IrStatement) {
    +"condition"
    const("target", "IrJumpTarget")
}

"IrIfTrue"(IrStatement) {
    +"condition"
    const("target", "IrJumpTarget")
}

addCode("// is IrBreak needed? maybe can be IrGoto")
"IrBreak"(IrStatement) {
    const("target", "IrJumpTarget")
}

addCode("// is IrContinue needed? maybe can be IrGoto")
"IrContinue"(IrStatement) {
    const("target", "IrJumpTarget")
}

"IrSwitch"(IrStatement) {
    +"expr"
    list("cases", "Pair<IrExpression, IrJumpTarget>")
}

"IrVariableDecl"(IrStatement) {
    list("variables", "Pair<String, IrExpression?>")
    const("kind", "VariableKind")
}

"IrThrow"(IrStatement) {
    +"exception"
}

"IrRethrow"(IrStatement) {
    const("internalVar", "IrInternalVariableId")
}

"IrEmptyStatement"(IrStatement) {
}

"IrExpressionStatement"(IrStatement) {
    +"expr"
}

addCode("// TODO: body")
"IrFunctionStatement"(IrStatement) {
}

"IrSetThisFn"(IrStatement) {
    const("name", "String")
}

// add handwritten types to type mapping
types[IrExpression]!!.addAll(arrayOf(
    "IrNumberLiteral",
    "IrStringLiteral",
    "IrNullLiteral",
    "IrBooleanLiteral",
    "IrRegexpLiteral",
    "IrIncDec",
))

types["IrIncDec"] = mutableListOf(
    "IrNameIncDec",
    "IrPropertyIncDec",
)

// add handwritten types to type mapping
types[IrStatement]!!.addAll(arrayOf(
    "IrBlockStatement",
))

types["IrBlockStatement"] = mutableListOf(
    "IrInternalScope",
    "IrBlock",
    "IrScope",
)

fun addSubclasses(name: String) {
    for (type in types[name].orEmpty()) {
        addCode("        $type::class,")
        addSubclasses(type)
    }
}

fun addRootClass(name: String) {
    addCode("@HasVisitor(")
    addCode("    visitorType = ${name}Visitor::class,\n")
    addCode("    hasCustomDataParam = true,\n")
    addCode("    acceptName = \"accept\",")
    addCode("    subclasses = [")
    addSubclasses(name)
    addCode("    ]")
    addCode(")")
    addCode("@HasAccept(\"visit${name.removePrefix("Ir")}\", $name::class)")
    addCode("sealed class $name : IrNode() {")
    addCode("    abstract fun <R, T> accept(visitor: ${name}Visitor<R, T>, arg: T): R")
    addCode("}")
    addCode()
}
addRootClass(IrExpression)
addRootClass(IrStatement)

// generate main file
File("IrNode.generated.kt").writeText(mainCode.toString())

File("IrVisitors.generated.kt").writeText(buildString {
    fun addVisit(parent: String) {
        for (name in types[parent].orEmpty()) {
            appendLine("    open fun visit${name.removePrefix("Ir")}(node: $name, arg: T): R" +
                    " = visit${parent.removePrefix("Ir")}(node, arg)")
            addVisit(name)
        }
    }

    appendLine(header)
    appendLine("abstract class IrExpressionVisitor<out R, in T> {")
    addVisit(IrExpression)
    appendLine("    abstract fun visitExpression(node: IrExpression, arg: T): R")
    appendLine("}")
    appendLine()
    appendLine("abstract class IrStatementVisitor<out R, in T> {")
    addVisit(IrStatement)
    appendLine("    abstract fun visitStatement(node: IrStatement, arg: T): R")
    appendLine("}")
})
