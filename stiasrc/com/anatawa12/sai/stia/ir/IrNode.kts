/**
 * regenerate with command shown below:
 *
 * kotlinc -script IrNode.kts
 */

@file:JvmName("IrNodeGen")
@file:Suppress("PropertyName")

import java.io.File

val mainCode = StringBuilder()

fun addCode(stat: Any? = null) {
    if (stat == null) mainCode.appendLine()
    else stat.toString().removeSuffix("\n").takeUnless { it == "" }?.let(mainCode::appendLine)
}

val IrExpression = "IrExpression"
val IrStatement = "IrStatement"
val types = mutableMapOf<String, MutableList<String>>()

class ClassGen(val name: String, val parent: String) {
    init {
        types.getOrPut(parent) { mutableListOf() }
            .add(name)
    }

    private val params = StringBuilder()
    private val init = StringBuilder()
    private val toString = mutableListOf<String>()
    private val body = StringBuilder()
    private val runWithChildExpressions = StringBuilder()

    fun const(name: String, type: String) = addConstant(name, type)
    fun list(name: String, type: String, expressionGetter: String? = null) = addList(name, type, expressionGetter)
    @Suppress("PropertyName")
    operator fun String.invoke(type: String) = add(this, type)
    @Suppress("PropertyName")
    operator fun String.unaryPlus() = add(this, IrExpression)

    private fun String.asFunName() = this.filter { it in 'a'..'z' || it in 'A'..'Z' }
        .let { if (endsWith('?')) "${it}Nullable" else it }

    fun addConstant(name: String, type: String) {
        params.appendLine("    val $name: $type,")
        toString.add("        \"$name=\$$name\" +")
    }

    fun add(name: String, type: String) {
        params.appendLine("    $name: $type,")
        init.appendLine("        this.$name = $name")
        toString.add("        \"$name=\$$name\" +")
        body.appendLine("    var $name: $type by nodeDelegateOf${type.asFunName()}()")
        when (type) {
            IrExpression -> runWithChildExpressions.appendLine("        func($name)")
            "$IrExpression?" -> runWithChildExpressions.appendLine("        $name?.let(func)")
        }
    }

    fun addList(name: String, type: String, expressionGetter: String? = null) {
        val setName = "set${name.let { it[0].toUpperCase() + it.substring(1) }}"
        params.appendLine("    $name: List<$type>,")
        init.appendLine("        $setName($name)")
        toString.add("        \"$name=\$$name\" +")
        body.appendLine("    private val ${name}Delegate = nodeListDelegateOf${type.asFunName()}()")
        body.appendLine("    val $name: MutableList<$type> by ${name}Delegate")
        body.appendLine("    fun $setName($name: List<$type>) = ${name}Delegate.set($name)")
        @Suppress("NAME_SHADOWING")
        val expressionGetter = expressionGetter ?: when (type) {
            IrExpression -> "it"
            "$IrExpression?" -> "it?"
            else -> null
        }
        if (expressionGetter != null)
            runWithChildExpressions.appendLine("        $name.forEach{ $expressionGetter.let(func) }")
    }

    fun print() {
        val visitName = "visit${name.removePrefix("Ir")}"
        addCode("@HasAccept(\"$visitName\", $parent::class)")
        addCode("class $name(")
        addCode(params)
        addCode(") : $parent() {")
        addCode(body)
        addCode()
        addCode("    init {")
        addCode(init)
        addCode("    }")
        addCode()
        addCode("    @Suppress(\"OVERRIDE_BY_INLINE\")\n")
        addCode("    override inline fun runWithChildExpressions(func: (IrExpression) -> Unit) {")
        addCode(runWithChildExpressions)
        addCode("    }")
        addCode()
        addCode("    override fun toString() = \"$name(\" +")
        val it = toString.iterator()
        for (s in it) {
            if (it.hasNext())
                addCode("$s \", \" +")
            else
                addCode(s)
        }
        addCode("    \")\"")
        addCode()
        addCode("    override fun <R, T> accept(visitor: ${parent}Visitor<R, T>, arg: T): R = visitor.$visitName(this, arg)")
        addCode("}")
        addCode()
    }
}

inline operator fun String.invoke(parent: String, block: ClassGen.() -> Unit) = ClassGen(this, parent).apply(block).print()

// header

val header = """
    /**
     * Generated by IrNode.kts
     * Do not modify manually
     */
    
    package com.anatawa12.sai.stia.ir
""".trimIndent()

addCode(header)
addCode()
addCode("import com.anatawa12.autoVisitor.HasAccept")
addCode("import com.anatawa12.autoVisitor.HasVisitor")
addCode()

// expressions

"IrBinaryOperator"(IrExpression) {
    const("type", "IrBinaryOperatorType")
    +"left"
    +"right"
}

"IrUnaryOperator"(IrExpression) {
    const("type", "IrUnaryOperatorType")
    +"expr"
}

"IrGetProperty"(IrExpression) {
    +"owner"
    +"name"
    const("isProp", "Boolean")
}

"IrSetProperty"(IrExpression) {
    +"owner"
    +"name"
    +"value"
    const("isProp", "Boolean")
}

"IrPropertyOperatorAssign"(IrExpression) {
    +"owner"
    +"name"
    const("isProp", "Boolean")
    const("operator", "IrBinaryOperatorType")
    +"operand"
}

"IrNewOrCall"(IrExpression) {
    +"function"
    list("args", IrExpression)
    const("isNewInstance", "Boolean")
}

"IrCommaExpr"(IrExpression) {
    list("exprs", IrExpression)
}

"IrConditional"(IrExpression) {
    +"condition"
    +"ifTrue"
    +"ifFalse"
}

addCode("// convert java exception to js object")
"IrConvertException"(IrExpression) {
    const("internalVar", "IrInternalVariableId")
}

// add handwritten types to type mapping
types[IrExpression]!!.addAll(arrayOf(
    "IrNumberLiteral",
    "IrStringLiteral",
    "IrNullLiteral",
    "IrBooleanLiteral",
    "IrRegexpLiteral",
    "IrIncDec",
    "IrSetName",
    "IrGetName",
))

types["IrIncDec"] = mutableListOf(
    "IrNameIncDec",
    "IrPropertyIncDec",
)

fun addSubclasses(name: String) {
    for (type in types[name].orEmpty()) {
        addCode("        $type::class,")
        addSubclasses(type)
    }
}

fun addRootClass(name: String) {
    addCode("@HasVisitor(")
    addCode("    visitorType = ${name}Visitor::class,\n")
    addCode("    hasCustomDataParam = true,\n")
    addCode("    acceptName = \"accept\",")
    addCode("    subclasses = [")
    addSubclasses(name)
    addCode("    ]")
    addCode(")")
    addCode("@HasAccept(\"visit${name.removePrefix("Ir")}\", $name::class)")
    addCode("sealed class $name : IrNode() {")
    addCode("    abstract fun runWithChildExpressions(func: (IrExpression) -> Unit)")
    addCode("    abstract fun <R, T> accept(visitor: ${name}Visitor<R, T>, arg: T): R")
    addCode("}")
    addCode()
}
addRootClass(IrExpression)

// generate main file
File("IrNode.generated.kt").writeText(mainCode.toString())

File("IrVisitors.generated.kt").writeText(buildString {
    fun addVisit(parent: String) {
        for (name in types[parent].orEmpty()) {
            appendLine("    open fun visit${name.removePrefix("Ir")}(node: $name, arg: T): R" +
                    " = visit${parent.removePrefix("Ir")}(node, arg)")
            addVisit(name)
        }
    }

    appendLine(header)
    appendLine("abstract class IrExpressionVisitor<out R, in T> {")
    addVisit(IrExpression)
    appendLine("    abstract fun visitExpression(node: IrExpression, arg: T): R")
    appendLine("}")
    appendLine()
})
